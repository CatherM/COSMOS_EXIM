---
title: "1_Preprocess_Transcriptomics"
author: "Cathy Magn√©e"
date: "2024-04-19"
output: html_document
execute:
echo: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Preprocessing Transcriptomics / RNAseq

This R Markdown document is a translation of the Rscripts 'Prepare_RNA.R' and ; Analyze_RNA.R, from the cosmosR (specifically, the FACTOR_COSMOS/scripts/RNA) github page.

### Loading...

Loading libraries:

```{r, echo=False}
# For the first part
library(readxl)
library(readr)
library(pheatmap)

# For the second part
# library(readr)
library(ggfortify)
library(decoupleR)
library(factoextra)
library(GSEABase)
# library(readxl)
library(tibble)
library(proxy)
library(data.table)
library(extrafont)
library(OmnipathR)

# These are super important... to me, but they take a longgg time to download so don't
# library(extrafont)
# font_import()
# loadfonts(device = "win")


```

If you are missing any libraries, specifically from Bioconductor, here uncomment any of the below:

```{r}
########## decoupleR
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("decoupleR")

########## GSEABase
# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# 
# BiocManager::install("GSEABase")

########## OmnipathR
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("OmnipathR")
```

Loading data.

```{r}
RNA_log2_FPKM <- as.data.frame(read_excel(path="data/RNA/RNA__RNA_seq_composite_expression.xls", skip = 10, sheet = 1))

# Our data would be:
# RNA_log2_FPKM <- as.data.frame(read_excel(path="data/Transcriptomics/EC024_raw counts.xls", sheet = 1))

```

Right now, this is Fragments per kilobase per million reads log2(FPKM + 1) --\> RNAseq, composite expression from <https://discover.nci.nih.gov/cellminer/datasets.do> ([https://discover.nci.nih.gov/cellminer/loadDownload.do)](https://discover.nci.nih.gov/cellminer/loadDownload.do))

However, this will change to our own data. (Hopefully)

### Reformatting data

Extracting RNAseq measurements and aligning cell line names.

```{r}
# Remove column 2 through 6 (Gene ID, chromosome, Start, End, Cytoband):
RNA_log2_FPKM <- RNA_log2_FPKM[,-c(2:6)] 

# Change first column to rowname, then remove first column:
rownames(RNA_log2_FPKM) <- RNA_log2_FPKM[,1] 
RNA_log2_FPKM <- RNA_log2_FPKM[,-1] 

# Reformat names of columns 
names(RNA_log2_FPKM) <- gsub(".*[:]","",names(RNA_log2_FPKM)) 
RNA_log2_FPKM <- RNA_log2_FPKM[,order(colnames(RNA_log2_FPKM))]
names(RNA_log2_FPKM) <- gsub("MDA-MB-231", "MDA-MB-231/ATCC", names(RNA_log2_FPKM)) 
names(RNA_log2_FPKM) <- gsub("RXF 393", "RXF-393", names(RNA_log2_FPKM)) 
```

In the above script, the following things happen:

1.  Column 2-6 are removed (Gene ID, Chromosome n the gene is on, Start and End place of gene, Cytoband)
2.  The first column is turned into the rownames and removed
3.  Special characters are removed from the gene names and the column are ordered by gene name alphabetically
4.  Two gene names get their special characters back.

### Transforming data

Inspecting distribution (interatively) and removing outliers.

First iteration:

```{r}
hist(as.numeric(unlist(RNA_log2_FPKM)), breaks = 1000)
hist.data = hist(as.numeric(unlist(RNA_log2_FPKM)), breaks = 1000, plot=F)
hist.data$counts = log10(hist.data$counts)
plot(hist.data, ylim = c(0,6), ylab='log10(Frequency)', xlab = "RNA log2 FPKM")


```

In the above script, the following things happen: 1. A histogram is created using the numeric data of all the genes and samples, but it is very ugly (see figure 1) 2. The data is logtransformed and replotted (see the second figure)

Iteration 2:

```{r}
hist(as.numeric(unlist(RNA_log2_FPKM[RNA_log2_FPKM>0])), breaks = 1000)
hist(as.numeric(unlist(RNA_log2_FPKM[RNA_log2_FPKM>=1])), breaks = 1000) 
RNA_log2_FPKM_clean <- RNA_log2_FPKM
RNA_log2_FPKM_clean[RNA_log2_FPKM_clean < 1] <- NA # Filter voor lage expressies, alles onder 1 word NA
mean(colSums(is.na(RNA_log2_FPKM_clean)))
hist(as.numeric(unlist(RNA_log2_FPKM_clean)), breaks = 1000, xlim = c(0,15)) 
dim(RNA_log2_FPKM_clean)
RNA_log2_FPKM_clean <- RNA_log2_FPKM_clean[rowSums(is.na(RNA_log2_FPKM_clean))<45,]
dim(RNA_log2_FPKM_clean)
hist(as.numeric(unlist(RNA_log2_FPKM_clean)), breaks = 1000, xlim = c(0,15)) 

```

In the above script, the following things happen:

1.  The data is shown first excluding only 0's (first figure), then excluding everything equal to and higher than 1 (second figure).
2.  The dataset is copied to a 'clean' version, of which all values below 1 is turned into NAs. Thus filtering out low expression values.
3.  The amount of NA values per column are summed, the mean of this is taken (\~14165.68)
4.  Only genes with less than 45/60 NAs are kept (\>75% NA is filtered out).The amount of genes drop from 23808 to 11265 (47% remains).
5.  The data is inspected again via histogram, which now nearly resembles a normal distribution.

### Including Plots

The clean dataset is visualized via heatmap

```{r pressure, echo=FALSE}
pheatmap(t(RNA_log2_FPKM_clean[,-1]), show_colnames = F, show_rownames = T, cluster_rows = T, cluster_cols = F, na_col = "grey", filename = "data/RNA/RNA_log2_FPKM_clean.pdf", width = 4, height = 7) 


```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

### Saving data

Overlapping clean and whole measurements are saved

```{r}
RNA_log2_FPKM <- cbind("Genes" = rownames(RNA_log2_FPKM), RNA_log2_FPKM)
RNA_log2_FPKM_clean <- cbind("Genes" = rownames(RNA_log2_FPKM_clean), RNA_log2_FPKM_clean)
write_csv(RNA_log2_FPKM,file = "data/RNA/RNA_log2_FPKM.csv")
write_csv(RNA_log2_FPKM_clean,file = "data/RNA/RNA_log2_FPKM_clean.csv")
```

## Analyzing our new and beautiful data

Loading data Keeping the second option in case you want/need to use data preprocessed differently. In that case, uncomment it.

I will also load the metadata here, which will be used later.

```{r}
RNA <- RNA_log2_FPKM_clean # Comment out this line if you want to use imported data for this part


# RNA <- as.data.frame(read_csv("data/RNA/RNA_log2_FPKM_clean.csv")) #Uncomment this.
# rownames(RNA) <- RNA[,1]


RNA <- RNA[,-1] # Keep this always <3

RNA_metadata <- read_csv(file = "data/metadata/RNA_metadata.csv")

```

### Filtering again?

Only keep genes where less than a third of the values are missing

```{r}
RNA <- RNA[rowSums(is.na(RNA)) < (dim(RNA)[2]/3),]

```

This further reduced the amount of genes from 11265 to 8465.

### Normalizing gene data across cell line

AKA per column

```{r}
SDs <- apply(RNA,1,function(x){sd(x,na.rm = T)})

means <- rowMeans(RNA, na.rm = T)

RNA <- (RNA - means) / SDs
```

### Transcription Factor clustering with normalized weighted mean approach (dorothea + decoupleR)

Transcription Factor(s) will from now on be referred to via TF(s) \### Load resources

```{r}
load("support/dorothea_df.RData")

```

### TF actifity calculations per cell line

```{r}
TF_activity <- apply(RNA,2,function(x){ # the 2 means per column (== per cell line)
  x <- as.data.frame(x[which(!is.na(x))]) # put all values in a df, but not NAs!
  TFs <- run_ulm(as.matrix(x), network = dorothea_df, minsize = 20) 
  # run an ulm (univariate lineare model), using the PKN (prior knowledge network) of dorothea, essentially predicting TF activity based on the available relevant RNA values
  TFs <- as.data.frame(TFs)
  TFs <- TFs[which(TFs$statistic == "ulm"),c(2,4)]
  as_input <- TFs[,2]
  names(as_input) <- TFs[,1]
  return(as_input)
})

## Convert into data.frame
TF_activity_df <- data.frame(t(data.table::rbindlist(
  lapply(TF_activity, function(x) data.table::data.table(t(x))),
  fill = TRUE)))
colnames(TF_activity_df) <- names(TF_activity)

# ## Scale the TF activities (obsolete)
# SDs <- apply(TF_activity_df,1,function(x){sd(x,na.rm = T)})
# means <- rowMeans(TF_activity_df, na.rm = T)
# TF_activity_scaled_df <- (TF_activity_df - means) / SDs
# 

#We don't scale the TF themselves since the RNA is already scaled
TF_activity_scaled_df <- TF_activity_df
```

What is happening in the chunk above:

1.  In the first chunk, an univariate linear model (ULM) takes all values (excluding NAs) and Dorothea's Prior Knowledge Network (PKN). Based on the scaled RNA values and Dorothea's knowledge on all validated gene regulatory networks (GRNs), it calculates transcription factor activities. This happens in only the first 2-3 lines! After this, the dataset is transformed into a dataframe, of which only the names and values of the transcription factors are kept. (Fleur, if you read this, there is also an option to keep the p-values. I will look up it Dorothea/run_ULM has already chosen only the Tf's with p-value \<0.050 // It has not, but I cannot find a way to extract the p-values. ).

2.  TF_activities is then transformed into a proper df, instead of the abomination that the chunk above produces.

3.  The option to scale the TF activities afterwards is commented out, as the RNA's were already scaled. If you used non-scaled RNA data for this, I suggest you scale that first. If you are headstrong or lazy, uncomment this section and run this to scale the TF activities.

In the next section, transcription factor activities are further transformed and analyzed.

\### Ranked TF

```{r}
# ## Convert values to ranks (from lowest to highest activity) with only complete cases

TF_activity_scaledrank_df <- as.data.frame(apply(TF_activity_df[complete.cases(TF_activity_df),], 2, base::rank))

```

### Visualization between cell lines

```{r}
## Visualize correlation of TFs between different cell lines
TF_activity_scaledrank_df_corr <- TF_activity_scaledrank_df %>%
  as.matrix %>%
  cor %>%
  as.data.frame %>%
  rownames_to_column(var = 'var1') %>%
  gather(var2, value, -var1) %>%
  pivot_wider(names_from = var1, values_from = value) %>%
  as.data.frame()
rownames(TF_activity_scaledrank_df_corr) <- TF_activity_scaledrank_df_corr$var2
TF_activity_scaledrank_df_corr <- TF_activity_scaledrank_df_corr[,-1]
pheatmap(TF_activity_scaledrank_df_corr)
```

The cell lines are plotted both on thex and y-axis. Cell lines that have similar TF activities are plotted closer together. In the following section, the cell lines that have similar TF activities are being clustered. First, the optimal number of clusters is chosen.

As they have different cell lines, I do think this is interesting data. However, we have one cell line (PGA-1) so I think this data will be less interesting to us. To make sure it is not interesting whatsoever, we will plot this anyway. The annotations will be less.

## [OPTIONAL] Optimal number of clusters determination

Method 1: Silhouette method

```{r}

## Determine optimal number of clusters
df <- as.data.frame(t(TF_activity_df[complete.cases(TF_activity_df),]))
### Silhouette method
fviz_nbclust(df, kmeans, method = "silhouette", k.max = 10)+
  labs(title="") +
  geom_vline(xintercept = 4, linetype = 2) +
  theme_bw() + 
  theme(axis.title.x = element_text(family = "Comic Sans MS"), 
        axis.title.y = element_text(family = "Comic Sans MS"), 
        axis.text = element_text(family = "Comic Sans MS"))

```

Method 2: Elbow method

```{r}
### Elbow method
fviz_nbclust(df, kmeans, method = "wss", k.max = 30) +
  geom_vline(xintercept = 3, linetype = 2) +
  geom_vline(xintercept = 4, linetype = 2) +
  geom_vline(xintercept = 6, linetype = 2) +
  geom_vline(xintercept = 9, linetype = 2)
```

Their conclusion: 3 clusters seems to be an alright number based on silhouet, elbow and interpretability needs.

```{r}
## Perform k-mean clustering and assign cell lines to clusters (here: explore different numbers based on peaks in Silhouette plot)

RNA_kmeans <- list()
SD <- list()
clusters_df <- list()
heatmap_avgrank_reduced <- list()
heatmap_avgNES_reduced <- list()
heatmap_cluster <- list()
pc_plot <- list()
RNA_metadata_cluster <-  list()
TF_activity_cluster_avgNES <-  list()
TF_activity_cluster_avgNES_reduced <- list()
TF_activity_cluster_avgrank <- list()
TF_activity_cluster_avgrank_reduced <- list()

# for(i in c(3,4,6,9)) {
for(i in c(3)) {  
  #Set seed so assignment to clusters is consistent across multiple runs
  set.seed(12) 
  print(i)
  RNA_kmeans[[i]] <- kmeans(df, i, iter.max = 10000, nstart = 100)
  
  ## Extract clusters
  clusters <- data.frame("cluster" = RNA_kmeans[[i]]$cluster)
  
  ## Inspect clustering
  RNA_kmeans[[i]]$cluster <- data.frame("Cell_line"=names(RNA_kmeans[[i]]$cluster),
                                        "Cluster"=as.character(RNA_kmeans[[i]]$cluster))
  
  pc_plot[[i]] <- autoplot(prcomp(t(TF_activity_scaled_df[complete.cases(TF_activity_scaled_df),])), 
           data = RNA_kmeans[[i]]$cluster,
           colour = "Cluster") +
    theme_bw() +
    scale_color_manual(values=c("1"="red", "2"="cyan", "3"="orange")) +
    scale_fill_manual(values=c("1"="red", "2"="cyan", "3"="orange")) + 
    theme(axis.title.x = element_text(family = "Times New Roman"), 
          axis.title.y = element_text(family = "Times New Roman"), 
          axis.text = element_text(family = "Times New Roman"), 
          legend.text = element_text(family = "Times New Roman"), 
          legend.title = element_text(family = "Times New Roman"))
  
    ## Size of clusters (amount of cell lines per cluster)
  table(RNA_kmeans[[i]]$cluster)
  table(clusters)
  
  ## Cell line TF activity with cluster assignment
  anno_colors <- list(
    "Cluster"=c("1"="red", "2"="cyan", "3"="orange")
  )
  anno_col <- data.frame("Cluster"=as.character(RNA_kmeans[[i]]$cluster$Cluster), 
                         row.names = RNA_kmeans[[i]]$cluster$Cell_line)
  
  heatmap_cluster[[i]] <- pheatmap(TF_activity_scaled_df[,order(RNA_kmeans[[i]]$cluster$Cluster)], 
                                   annotation_col = anno_col, 
                                   annotation_colors = anno_colors,
                                   cluster_cols = F, 
                                   show_rownames = F, 
                                   show_colnames = F,
                                   fontfamily = "Times New Roman",
                                   fontsize = 12, 
                                   color = colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name = "RdBu")))(100),
                                   breaks = seq(-4,4,8/100))
  
  ## Compare average of TF values per cluster
  ggpubr::compare_means(value ~ Cluster,
                merge(cbind(pivot_longer(TF_activity_scaled_df,
                                         cols = colnames(TF_activity_scaled_df),
                                         names_to = "sample",
                                         values_to = "value"), 
                            "feature"=rep(rownames(TF_activity_scaled_df),60)), 
                      RNA_kmeans[[i]]$cluster, by.x = "sample", by.y = "Cell_line"),
                method="t.test",
                p.adjust.method = "BH",
                paired = F,
                alternative = "two.sided")
  
  ## Compare to cell line metadata
  clusters_df[[i]] <- cbind("cell_line"=rownames(clusters),clusters)
  RNA_metadata_cluster[[i]] <- merge(clusters_df[[i]], RNA_metadata, by="cell_line")
  
  ## TF activity per cluster (calculate mean of cell lines per cluster)
  ### Based on TF activity ranks
  TF_activity_cluster_avgrank[[i]] <- as.data.frame(sapply(sort(unique(clusters$cluster)), function(x, TF_activity_scaledrank_df, clusters){
    df <- as.data.frame(TF_activity_scaledrank_df[,clusters[clusters$cluster == x, 'cell_line']])
    rownames(df) <- rownames(TF_activity_scaledrank_df)
    ifelse(!is.null(dim(df)), return(rowMeans(df, na.rm = T)), return(df))
  }, TF_activity_scaledrank_df = TF_activity_scaledrank_df, clusters = clusters_df[[i]], USE.NAMES = T))
  
  ### Based on TF activity values
  TF_activity_cluster_avgNES[[i]] <- as.data.frame(sapply(sort(unique(clusters$cluster)), function(x, TF_activity_scaled_df, clusters){
    df <- as.data.frame(TF_activity_scaled_df[,clusters[clusters$cluster == x, 'cell_line']])
    rownames(df) <- rownames(TF_activity_scaled_df)
    ifelse(!is.null(dim(df)), return(rowMeans(df, na.rm = T)), return(df))
  }, TF_activity_scaled_df = TF_activity_scaled_df, clusters = clusters_df[[i]], USE.NAMES = T))
  
  ### Keep top 25 variable genes (based on ranks = scale-free)
  SDs <- apply(TF_activity_cluster_avgrank[[i]], 1, sd)
  SDs <- sort(SDs, decreasing = T)[1:25]
  SD[[i]] <- SDs
  
  ## Reorder based on SD value
  TF_activity_cluster_avgrank_reduced[[i]] <- TF_activity_cluster_avgrank[[i]][names(SDs),]
  TF_activity_cluster_avgNES_reduced[[i]] <- TF_activity_cluster_avgNES[[i]][names(SDs),]
  
  ## Inspect results
  heatmap_avgrank_reduced[[i]] <- pheatmap(TF_activity_cluster_avgrank_reduced[[i]], cluster_rows = F, cluster_cols = F, display_numbers = T)
  
  colnames(TF_activity_cluster_avgNES_reduced[[i]]) <- c("Cluster 1","Cluster 2","Cluster 3")
  heatmap_avgNES_reduced[[i]] <- pheatmap(TF_activity_cluster_avgNES_reduced[[i]], 
                                          cluster_rows = T, 
                                          cluster_cols = F, 
                                          display_numbers = F,
                                          fontfamily = "Times New Roman",
                                          fontsize = 12,
                                          angle_col = 0,
                                          color = colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name = "RdBu")))(100))
  
  ggpubr::compare_means(value ~ Cluster,
                pivot_longer(TF_activity_cluster_avgNES_reduced[[i]],
                             cols=colnames(TF_activity_cluster_avgNES_reduced[[i]]),
                             values_to = "value", 
                             names_to = "Cluster"),
                method="t.test",
                p.adjust.method = "BH",
                paired = F,
                alternative = "two.sided")
}
```

Let's NOT unwind all that happens above because I would rather spend my time elsewhere.

```{r}
# Print number of samples per cluster
lapply(clusters_df[!unlist(lapply(clusters_df,is.null))], function(x) table(x$cluster))

# Compare clusters by top TFs by similarity (Jaccard distance)
# overlap <- data.frame(rbind(NA,data.table::rbindlist(
#   lapply(SD[!unlist(lapply(SD,is.null))], function(x) data.table::data.table(t(x))),
#   fill = TRUE
# ), fill=T))[-1,-1]
# overlap[is.na(overlap)] <- 0
# overlap[overlap>0] <- 1
# rownames(overlap) <- c("3","4","6","9")
# colnames(overlap) <- c("3","4","6","9")
# pheatmap(simil(overlap, overlap, method = "Jaccard"), cluster_cols = F, cluster_rows = F, display_numbers = T)

# Compare clusters by cell line assignment
cluster_number <- 3
tissue_origin_cluster <- RNA_metadata_cluster[[cluster_number]][,c(2:3,8)]
colnames(tissue_origin_cluster) <- c("cluster", "tissue", "histology")
rownames(tissue_origin_cluster) <- RNA_metadata_cluster[[cluster_number]][,1]
pheatmap(TF_activity_scaled_df[,order(RNA_metadata_cluster[[cluster_number]]$cluster)], annotation_col = tissue_origin_cluster, cluster_cols = F, show_rownames = F, show_colnames = T)

cell_clusters <- lapply(clusters_df[!unlist(lapply(clusters_df,is.null))], function(x) lapply(clusters_df[!unlist(lapply(clusters_df,is.null))], function(y){
  d <- simil(table(reshape2::melt(x, id.var = -1)[-2]),
      table(reshape2::melt(y, id.var = -1)[-2]),
      method = "Jaccard")
  if(dim(d)[1]!=dim(d)[2]) pheatmap(d, cluster_rows = F, cluster_cols = F)
}))


# Inspect cluster by heatmap
lapply(pc_plot[!unlist(lapply(pc_plot,is.null))], function(x) x)

plot.new()
heatmap_cluster[[3]]

# plot.new()
# heatmap_cluster[[4]]
# plot.new()
# heatmap_cluster[[6]]
# plot.new()
# heatmap_cluster[[9]]



plot.new()
heatmap_avgNES_reduced[[3]]
# plot.new()
# heatmap_avgNES_reduced[[4]]
# plot.new()
# heatmap_avgNES_reduced[[6]]
# plot.new()
# heatmap_avgNES_reduced[[9]]

```

Now they save the clusters using the following code, that I will comment out because I am not here to save their stuff \<3

```{r}

## Save optimal cluster result (here: 3)
# write_csv(RNA_metadata_cluster[[3]], file = "data/metadata/RNA_metadata_cluster.csv")

```

## [Not Optional] Gene reduction

After all the clustering stuff, the authors start a section called 'Justify reduction of genes'. It starts off reimporting some already imported libraries. Hence I commented this out. If you want to do this in a separate script, these are the libraries I think you might need:

```{r}
# Importing libaries that are already here with us
# 
# library(readr)
# library(ggfortify)
# library(decoupleR)
# library(factoextra)
# library(GSEABase)
# library(readxl)
library(dplyr)
```

And the data, I will reload just in case:

```{r}
# (Re)Loading transcriptomics

RNA <- as.data.frame(read_csv("data/RNA/RNA_log2_FPKM_clean.csv"))
rownames(RNA) <- RNA[,1]
RNA <- RNA[,-1]
```

Removing genes with excessive (\>1/3) NAs and loading dorothea (Will need to change this to CollecTRI) or do I?

```{r}
# Remove genes with excessive amount of NAs (only keep genes with max. amount of NAs = 33.3 % across cell lines)
RNA <- RNA[rowSums(is.na(RNA))<(dim(RNA)[2]/3),]

load("support/dorothea_df.RData")
# TF clustering with normalized weighted mean approach (dorothea + decoupleR)
## First load ressource
# dorothea_df <- decoupleR::get_dorothea(levels = c("A","B","C"))
```

Then, depending on the size of the gene dataset, the TFs and the mean number of targets per TF is extracted:

```{r, warning=FALSE, echo=T, results='hide'}
# Extract number of TFs and mean number of targets per TF depending on gene data set size
results_table <- list()
for(i in c(seq(1,dim(RNA)[1],200))){ # From 1 to rowcount of RNA, by = 200
  
  RNA_sd <- sort(apply(RNA, 1, function(x) sd(x,na.rm = T)), decreasing = T) # the 1 indicates rows. Rows are sorted by decreasing sd
  RNA_sd <- RNA_sd[1:i]
  RNA_reduced <- RNA[names(RNA_sd),] # Basically creates a subset of the RNA's of 1:i? in which i is a mulitple of 200?
  
  ## Normalize gene data across cell lines 
  SDs <- apply(RNA_reduced,1,function(x){sd(x,na.rm = T)}) # SD is calculated per gene (row) (again)
  means <- rowMeans(RNA_reduced, na.rm = T) # Mean is also calculated per gene  (row)
  RNA_reduced <- (RNA_reduced - means) / SDs # (RNA - mean ) / SD == z-score, normalized RNA values across all cell lines
  
  ## Calculate TF activities per cell line
  TF_activity_reduced <- apply(RNA_reduced,2,function(x){ # per cell line (column)
    x <- as.data.frame(x[which(!is.na(x))]) # only take non-NA values
    dorothea_df_intersected <- as.data.frame(intersect_regulons(mat = x, network = dorothea_df, minsize = 20, .source = source, .target = target))[,c(1,3)] # activities based on these gene values
  })
  
  ## Extract overlapping TFs
  overlap_TF <- lapply(c(1:length(TF_activity_reduced)),function(x) unique(TF_activity_reduced[[x]]$source)) %>%
    reshape2::melt() %>%
    count(value) # Tallies how often the x appears?
  overlap_TF <- unique(overlap_TF[overlap_TF$n==length(TF_activity_reduced),1])
  TF_activity_reduced <- lapply(c(1:length(TF_activity_reduced)),function(x) TF_activity_reduced[[x]][TF_activity_reduced[[x]]$source %in% overlap_TF,])
  
  ## Calculate mean of TF targets and SD considering all cell lines 
  TF_activity_reduced_df <- data.frame(t(mapply(function(x) data.frame("mean"=mean(table(TF_activity_reduced[[x]]$source)), "sd"=sd(table(TF_activity_reduced[[x]]$source))), c(1:length(TF_activity_reduced)))))
  
  ## Save how many genes were considered, mean and SD of TF targets as well as numer of identified TFs
  results_table[[i]] <- data.frame("mean"=mean(melt(TF_activity_reduced_df$mean)[,1]),
                                   "sd"=mean(melt(TF_activity_reduced_df$sd)[,1]),
                                   "Number_of_TFs"=length(overlap_TF),
                                   "Number_of_genes"=i)
  results_table[[i]][is.na(results_table[[i]])] <- 0 
  # print(i)
}

```

Let's look at the above chunk step-by-step.

1.  Iterating per 200 steps over the rows of RNA. (1 row = 1 gene) The standard deviation is calculated over the 1- to i'th values (so an increasing number of rows, 42 iterations)

2.  The normalized gene data is mapped onto the dorothea networks (excluding NAs) to find TF activities

3.  Only unique TF activities are sampled. The ones that are overlapping are being merged into 1 using melt

4.  for each row, the mean, sd, n TFs and number of genes used is listed in the results_table

These results are then saved and reloaded because why not:

```{r}
# save(results_table,file = "results/RNA/TF_TFtarget_gene_reduction.Rdata")
load(file = "results/RNA/TF_TFtarget_gene_reduction.Rdata")
```

And the results table turned into a df:

```{r}
## From list to data frame
results_table_df <- data.frame()
for (i in c(1:length(results_table))) {
  results_table_df <- rbind(results_table_df, results_table[[i]])
}
```

Results table is then plotted:

```{r}
## Plot result with two y axis (function of TF targets and TFs depending on number of genes)

plot <- ggplot(results_table_df, aes(Number_of_genes,Number_of_TFs)) +
  geom_point(color = "blue", size = 0.1) +
  geom_line(aes(color = "Number of TFs")) +
  # geom_line(aes(y=sd, color = "SD of TF targets per TF")) +
  geom_point(aes(y = mean, color = "red"), size = 0.1) +
  geom_line(aes(y = mean, color = "Average TF targets per TF")) +
  scale_y_continuous("Number of TFs", breaks = seq(0,230,10), sec.axis = sec_axis(~ ., name = "Average TF targets per TF", breaks = seq(0,230,10))) +
  scale_x_reverse("Number of genes") +
  scale_color_manual(name = "", values = c("Number of TFs" = "blue", "Average TF targets per TF" = "red")) +
  # scale_color_manual(name = "", values = c("Number of TFs" = "blue", "Average TF targets per TF" = "red", "SD of TF targets per TF" = "#FFCCCB")) +
  # ggtitle("Number of identified transcription factors and targets (mean) depending on number of genes") +
  theme_bw() +
  geom_vline(xintercept = 6000) +
  theme(axis.title.y.left =element_text(colour = "blue"),axis.title.y.right =element_text(colour = "red"),
        # axis.title.x = element_text(family = "Times New Roman"),
        # axis.title.y = element_text(family = "Times New Roman"),
        # axis.text = element_text(family = "Times New Roman"),
        # legend.text = element_text(family = "Times New Roman"),
        # legend.title = element_text(family = "Times New Roman"))
  )

```

and this plot is saved

```{r}
ggsave(file="results/RNA/TF_TFtarget_gene_reduction.pdf", device = "pdf", plot = plot, width = 5, height = 2.2)

```

This is me plotting the plot because why NOT

```{r}
plot
```

This plot shows the correlation between the total number of genes, TFs and the average TF targets per TF. What I am taking from this plot is that for 3000-8000 genes, the amount of TF's does increase, but the average number of TF targets per TF does not.

Interpret this further. The average amount of transcription factor targets does not grow with the increased number of genes. Why not?
